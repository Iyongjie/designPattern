# 定义

迪米特原则(Law of Demeter,LoD)，也叫最少知识原则(Low knowledge Principle,LKP):

> **迪米特法则(Law of  Demeter, LoD)：一个软件实体应当尽可能少地与其他实体发生相互作用。**

通俗的讲：一个类对自己需要耦合或调用的类知道的最少，你(被耦合或调用的类)的内部是如何复杂和我没有关系，我就知道你提供的public方法，我只调用这些方法，其它的我不关心。

 如果一个系统符合迪米特法则，那么当其中某一个模块发生修改时，就会尽量少地影响其他模块，扩展会相对容易，这是对软件实体之间通信的限制，迪米特法则要求限制软件实体之间通信的宽度和深度。**迪米特法则可降低系统的耦合度，使类与类之间保持松散的耦合关系。**

> 迪米特法则还有几种定义形式，包括：**不要和“陌生人”说话、只与你的直接朋友通信等**，在迪米特法则中，对于一个对象，其朋友包括以下几类：
>
> (1) 当前对象本身(this)；
>
> (2) 以参数形式传入到当前对象方法中的对象；
>
> (3) 当前对象的成员对象；
>
> (4) 如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友；
>
> (5) 当前对象所创建的对象。
>
> **任何一个对象，如果满足上面的条件之一，就是当前对象的“朋友”，否则就是“陌生人”。**在应用迪米特法则时，一个对象只能与直接朋友发生交互，不要与“陌生人”发生直接交互，这样做可以降低系统的耦合度，一个对象的改变不会给太多其他对象带来影响。

> 迪米特法则要求我们在设计系统时，**应该尽量减少对象之间的交互，如果两个对象之间不必彼此直接通信，那么这两个对象就不应当发生任何直接的相互作用，如果其中的一个对象需要调用另一个对象的某一个方法的话，可以通过第三者转发这个调用**。简言之，**就是通过引入一个合理的第三者来降低现有对象之间的耦合度。（中间件,很重要）**

>  在将迪米特法则运用到系统设计中时，要注意下面的几点：**在类的划分上，应当尽量创建松耦合的类，类之间的耦合度越低，就越有利于复用，一个处在松耦合中的类一旦被修改，不会对关联的类造成太大波及**；**在类的结构设计上，每一个类都应当尽量降低其成员变量和成员函数的访问权限**；**在类的设计上，只要有可能，一个类型应当设计成不变类**；**在对其他类的引用上，一个对象对其他对象的引用应当降到最低**。

------

# 模拟场景

      Sunny软件公司所开发CRM系统包含很多业务操作窗口，在这些窗口中，某些界面控件之间存在复杂的交互关系，一个控件事件的触发将导致多个其他界面控件产生响应，例如，当一个按钮(Button)被单击时，多个label 需要发生变化。

# 没有采用迪米特法则的UML图

没有采用迪米特法则的UML图

# 简单代码

> @interface ButtonEventView : UIView
>
> \- (instancetype)initWithFrame:(CGRect)frame Label1:(UILabel *)label1 Label2:(UILabel *)label2 Label3:(UILabel*)label3;
>
> @end

> \#import "ButtonEventView.h"
>
> @interface ButtonEventView()
>
> @property (nonatomic,strong) UILabel  *label1;
>
> @property (nonatomic,strong) UILabel  *label2;
>
> @property (nonatomic,strong) UILabel  *label3;
>
> @end
>
> @implementation ButtonEventView
>
> \- (instancetype)initWithFrame:(CGRect)frame Label1:(UILabel *)label1 Label2:(UILabel *)label2 Label3:(UILabel*)label3
>
> {
>
>     self = [super initWithFrame:frame];
>
>     if (self) {
>
>         self.label1 = label1;
>
>         self.label2=label2;
>
>         self.label3=label3;
>
>         [self createUI];
>
>     }
>
>     return self;
>
> }
>
> -(void)createUI{
>
>     UIButton * buton = [UIButton buttonWithType:UIButtonTypeCustom];
>
>     buton.frame = CGRectMake(0, 0, self.bounds.size.width, 50);
>
>     [buton setBackgroundColor:[UIColor redColor]];
>
>     [buton addTarget:self action:@selector(buttonEvent) forControlEvents:UIControlEventTouchDown];
>
>     [self addSubview:buton];
>
> }
>
> -(void)buttonEvent{
>
>     self.label1.text = @"label1";
>
>     self.label2.text = @"label2";
>
>     self.label3.text = @"label3";
>
> }
>
> @end

测试代码

> -(UILabel *)getLabel{
>
>     static int i=0;
>
>     i++;
>
>     UILabel * label = [[UILabel alloc]initWithFrame:CGRectMake(0, i*60, self.view.bounds.size.width, 50)];
>
>     label.backgroundColor = [UIColor blueColor];
>
>     label.textColor=[UIColor blackColor];
>
>     [self.view addSubview:label];
>
>     return label;
>
> }
>
> ///迪米特法则
>
> -(void)PLK{
>
>     ButtonEventView* button = [[ButtonEventView alloc]initWithFrame:CGRectMake(0, 0, self.view.bounds.size.width, 50) Label1:[self getLabel] Label2:[self getLabel] Label3:[self getLabel]];
>
>     [self.view addSubview:button];
>
> }

点击button之前的图

没有点击button

点击button之后效果

点击之后效果

假设我们现在需要新增一个Label .那我们就只能修改ButtonEventView 类了，增加一个label属性，并且要修改初始化方法。这主要是ButtonEventView和Label之间紧耦合导致的的。解决办法入下图

------

# 采用迪米特法则的UML图

采用迪米特法则的UML图

# 代码重构

> @protocol MediaterProtocol<NSObject>
>
> -(void)buttonEvent;
>
> @end

> \#import "MediaterProtocol.h"
>
> @interface Mediater : NSObject<MediaterProtocol>
>
> \- (instancetype)initWithLabel1:(UILabel *)label1 Label2:(UILabel *)label2 Label3:(UILabel*)label3;
>
> @end

> \#import "Mediater.h"
>
> @interface Mediater()
>
> @property (nonatomic,strong) UILabel  *label1;
>
> @property (nonatomic,strong) UILabel  *label2;
>
> @property (nonatomic,strong) UILabel  *label3;
>
> @end
>
> @implementation Mediater
>
> \- (instancetype)initWithLabel1:(UILabel *)label1 Label2:(UILabel *)label2 Label3:(UILabel*)label3
>
> {
>
>     self = [super init];
>
>     if (self) {
>
>         self.label1 = label1;
>
>         self.label2=label2;
>
>         self.label3=label3;
>
>     }
>
>     return self;
>
> }
>
> -(void)buttonEvent{
>
>     self.label1.text = @"label1";
>
>     self.label2.text = @"label2";
>
>     self.label3.text = @"label3";
>
> }
>
> @end

> \#import "MediaterProtocol.h"
>
> @interface ButtonEventNewView : UIView
>
> \- (instancetype)initWithFrame:(CGRect)frame mediator:(id<MediaterProtocol>)mediator;
>
> @end

> \#import "ButtonEventNewView.h"
>
> @interface ButtonEventNewView()
>
> @property (nonatomic,strong) id<MediaterProtocol>mediater;
>
> @end@implementation ButtonEventNewView
>
> \- (instancetype)initWithFrame:(CGRect)frame mediator:(id<MediaterProtocol>)mediator
>
> {
>
>     self = [super initWithFrame:frame];
>
>     if (self) {
>
>         self.mediater = mediator;
>
>         [self createUI];
>
>     }
>
>     return self;
>
> }
>
> -(void)createUI{
>
>     UIButton * buton = [UIButton buttonWithType:UIButtonTypeCustom];
>
>     buton.frame = CGRectMake(0, 0, self.bounds.size.width, 50);
>
>     [buton setBackgroundColor:[UIColor redColor]];
>
>     [buton addTarget:self action:@selector(buttonEvent) forControlEvents:UIControlEventTouchDown];
>
>     [self addSubview:buton];
>
> }
>
> -(void)buttonEvent{
>
>     [self.mediater buttonEvent];
>
> }
>
> @end

测试代码

> Mediater * mediater = [[Mediater alloc]initWithLabel1:[self getLabel] Label2:[self getLabel] Label3:[self getLabel]];
>
>     ButtonEventNewView * button = [[ButtonEventNewView alloc]initWithFrame:CGRectMake(0, 0, self.view.bounds.size.width, 50) mediator:mediater];
>
>     [self.view addSubview:button];

测试结果和上面的截图一样

我们看出来这样我们增加新的label 不需要修改Button了，只需要修改Mediator就行。这样就降低了耦合度

------

# **迪米特原则的实践**

迪米特原则的核心观念就是类间解耦，弱耦合，只有弱耦合后，类的复用率才可以提高。其结果就是产生了大量的中转或跳转类，导致系统复杂，为维护带来了难度。所以，我们在实践时要反复权衡，即要让结构清晰，又做到高内聚低耦合。

参考博客

[面向对象设计原则之迪米特法则](https://blog.csdn.net/lovelion/article/details/7563445)

[六大设计原则之迪米特原则](https://blog.csdn.net/hfreeman2008/article/details/52335601)

[源代码地址](https://github.com/NPOpenSource/designPattern)

下一篇博客

[创建型设计模式 -单例模式](https://www.jianshu.com/p/4b5253f753a7)