# 定义

> **High level modules should not depend upon low level modules,Both should depend upon abstractions.Abstractions should not depend upon details.Details should depend upon abstracts.**

翻译过来：

1.高层模块不应该依赖低层模块，两者都应该依赖抽象

2.抽象不应该依赖细节

3.细节应该依赖抽象

**也可以说高层模块，低层模块，细节都应该依赖抽象**

> **每一个逻辑的实现都是由颗粒原子逻辑组成的，颗粒原子逻辑就是低层模块，而颗粒原子逻辑组成的模块就是高层模块。在ios语言中，抽象就是协议，不能直接被实例化的，细节就是实现类，实现协议而产生的类就是细节，可以直接被实例化。**

### 具体表现

模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是协议产生的。

协议不依赖实现类

实现类依赖协议

**更加精简的定义就是“面向接口编程”—OOD(Object-Oriented Design，面向对象设计)的精髓之一。**

* * *

# 优点

采用依赖倒置原则可以减少类间的耦合性，提高系统的稳定，降低并行开发引起的风险，提高代码的可读性和可维护性。

* * *

# 场景模拟

小明喜欢看文学作品

# 场景模拟UML 图

![image](http://upload-images.jianshu.io/upload_images/1682758-918e0f87cba21134?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

# 简单代码

> @interface LiteraryClassic : NSObject
>
> -(void)read;
>
> @end

> @implementation LiteraryClassic
>
> -(void)read{
>
>     NSLog(@"读文学经典");
>
> }
>
> @end

> #import "LiteraryClassic.h"
>
> @interface XiaoMing : NSObject
>
> -(void)read:(LiteraryClassic *)literaryClassic;
>
> @end

> @implementation XiaoMing
>
> -(void)read:(LiteraryClassic *)literaryClassic
>
> {
>
>     [literaryClassic read];
>
> }
>
> @end

测试

> LiteraryClassic * literary=[LiteraryClassic new];
>
>     XiaoMing * xiaoming=[XiaoMing new];
>
>     [xiaoming read:literary];

结果

> 2018-04-03 17:18:58.591721+0800 设计模式原则[77605:5784593] 读文学经典

这样小明就能看文学经典了。目前来看，没有啥问题。

* * *

# 场景变更

小明突然想看小说了。

# 场景变更UML图

![image](http://upload-images.jianshu.io/upload_images/1682758-2bdd8cf20c23d81e?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

# 场景变更代码实现

> @interface Novel : NSObject
>
> -(void)read;
>
> @end

> @implementation Novel
>
> -(void)read{
>
>     NSLog(@"读小说");
>
> }
>
> @end

修改小明类增加一个读小说的功能

> -(void)readnovel:(Novel*)novel;

> -(void)readnovel:(Novel*)novel{
>
>     [novel read];
>
> }

测试

> Novel * novel = [Novel new];
>
>     [xiaoming readnovel:novel];

结果

> 2018-04-03 17:37:14.518287+0800 设计模式原则[82210:5805086] 读小说

这样小明就可以读小说了。

虽然我们这样修改可以实现小明读小说，但是我们需要修改小明类。那么每增加一个类别，那么都要重新修改小明类。

导致这样的原因是因为**小明类与每种书籍都是强依赖，紧耦合导致的。**

具体分析

> 看小明类，此类是一个高层模块，并且是一个细节实现类，此类依赖的是一个文学经典LiteraryClassic类，而文学经典LiteraryClassic类也是一个细节实现类。这是不是就与我们说的依赖倒置原则相违背呢？**依赖倒置原则是说我们的高层模块，实现类，细节类都应该是依赖与抽象，依赖与接口和抽象类。**

* * *

# 代码重构UML图 

![image](http://upload-images.jianshu.io/upload_images/1682758-8243cd40ccc6cb1e?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

# 代码重构

> @protocol IRead<NSObject>
>
> -(void)read;
>
> @end

> #import "IRead.h"
>
> @interface LiteraryClassicNew : NSObject<IRead>
>
> @end

> @implementation LiteraryClassicNew
>
> -(void)read{
>
>     NSLog(@"读文学经典");
>
> }
>
> @end

> #import "IRead.h"
>
> @interface NovelNew : NSObject<IRead>
>
> @end

> #import "NovelNew.h"
>
> @implementation NovelNew
>
> -(void)read{
>
>     NSLog(@"读小说");
>
> }
>
> @end

> #import "IRead.h"
>
> @protocol IReader<NSObject>
>
> -(void)read:(id<IRead>)iread;
>
> @end

> #import "IReader.h"
>
> @interface XiaoMingNew : NSObject<IReader>
>
> @end

> #import "XiaoMingNew.h"
>
> @implementation XiaoMingNew
>
> -(void)read:(id<IRead>)iread{
>
>     [iread read];
>
> }
>
> @end

测试

> id<IReader>ireader=[XiaoMingNew new];
>
> id<IReader> read = [NovelNew new];
>
>     [ireader read:read];
>
>     read=[LiteraryClassicNew new];
>
>     [ireader read:read];

结果

> 2018-04-03 18:04:03.545562+0800 设计模式原则[89054:5835572] 读小说
>
> 2018-04-03 18:04:03.545770+0800 设计模式原则[89054:5835572] 读文学经典

这样设计我们发现，小明和文学经典还是小说就没有耦合和依赖关系，依赖关系是靠协议之间。这就是依赖倒置原则，我们依赖的对象是一个协议，就可以适应所有实现此协议的具体类的变化。

* * *

# 依赖的三种方法

依赖是可以传递，A对象依赖B对象，B又依赖C，C又依赖D，……，依赖不止。只要做到抽象依赖，即使是多层的依赖传递也无所谓惧。 

### 构造函数传递依赖对象

### Setter方法传递依赖对象

### 接口声明依赖

这上面三种依赖其实就是传入的参数是个协议，而不是具体类而已。

* * *

# 依赖倒置原则的经验

依赖倒置原则的本质就是通过抽象(协议)使各个类或模块的实现彼此独立，不互相影响，实现模块间的松耦合。我们在项目中使用这个原则要遵循下面的规则：

> 每个类尽量都有协议类
>
> 任何类都不应该从具体类派生
>
> 尽量不要覆写基类的方法 
>
> 结合里氏替换原则使用

依赖倒置原则是6个设计原则中最难以实现的原则，它是实现开闭原则的重要方法，在项目中，大家只要记住是”面向接口编程”就基本上是抓住了依赖倒置原则的核心了。

[源代码地址](https://github.com/NPOpenSource/designPattern)

参考博客

[六大设计原则之依赖倒置原则](https://blog.csdn.net/hfreeman2008/article/details/52289571)

下一篇博客

[设计模式原则之接口隔离原则](https://www.jianshu.com/p/f411d6f477ac)